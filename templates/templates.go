package templates

import (
	"embed"
	"fmt"
	permission1 "github.com/ystv/web-auth/infrastructure/permission"
	"github.com/ystv/web-auth/permission"
	"github.com/ystv/web-auth/permission/permissions"
	"github.com/ystv/web-auth/role"
	"github.com/ystv/web-auth/user"
	"html/template"
	"io"
	"log"
	"time"
)

//go:embed *.tmpl
var tmpls embed.FS

type Templater struct {
	Permission *permission.Store
	Role       *role.Store
	User       *user.Store
}

type Template string

const (
	ForgotTemplate       Template = "forgot.tmpl"
	NotFound404Template  Template = "404NotFound.tmpl"
	ForgotEmailTemplate  Template = "forgotEmail.tmpl" // generated by go generate
	InternalTemplate     Template = "internal.tmpl"
	LoginTemplate        Template = "login.tmpl"
	NotificationTemplate Template = "notification.tmpl"
	ResetTemplate        Template = "reset.tmpl"
	ErrorTemplate        Template = "error.tmpl"
	SettingsTemplate     Template = "settings.tmpl"
	SignupTemplate       Template = "signup.tmpl"
	UserTemplate         Template = "user.tmpl"
	UsersTemplate        Template = "users.tmpl"
	RolesTemplate        Template = "roles.tmpl"
	RoleTemplate         Template = "role.tmpl"
	ResetEmailTemplate   Template = "resetEmail.tmpl" // generated by go generate
	PermissionsTemplate  Template = "permissions.tmpl"
	PermissionTemplate   Template = "permission.tmpl"
)

type TemplateType int

const (
	NoNavType TemplateType = iota
	PaginationType
	RegularType
)

func NewTemplate(p *permission.Store, r *role.Store, u *user.Store) *Templater {
	return &Templater{
		Permission: p,
		Role:       r,
		User:       u,
	}
}

func (t Template) String() string {
	return string(t)
}

func (t *Templater) RenderTemplate(w io.Writer, data interface{}, mainTmpl Template, templateType TemplateType) error {
	var err error

	t1 := template.New("_base.tmpl")

	t1.Funcs(t.getFuncMaps())

	switch templateType {
	case NoNavType:
		t1, err = t1.ParseFS(tmpls, "_base.tmpl", "_bodyNoNavs.tmpl", "_head.tmpl", "_footer.tmpl", mainTmpl.String())
	case PaginationType:
		t1, err = t1.ParseFS(tmpls, "_base.tmpl", "_body.tmpl", "_head.tmpl", "_footer.tmpl", "_navbar.tmpl", "_sidebar.tmpl", "_pagination.tmpl", mainTmpl.String())
	case RegularType:
		t1, err = t1.ParseFS(tmpls, "_base.tmpl", "_body.tmpl", "_head.tmpl", "_footer.tmpl", "_navbar.tmpl", "_sidebar.tmpl", mainTmpl.String())
	default:
		return fmt.Errorf("unable to parse template, invalid type: %d", templateType)
	}

	if err != nil {
		log.Printf("failed to get templates for template(RenderTemplate): %+v", err)
		return err
	}

	return t1.Execute(w, data)
}

func (t *Templater) GetEmailTemplate(emailTemplate Template) (*template.Template, error) {
	return template.New(emailTemplate.String()).ParseFS(tmpls, emailTemplate.String())
}

func (t *Templater) getFuncMaps() template.FuncMap {
	return template.FuncMap{
		"now": func() time.Time {
			return time.Now()
		},
		"thisYear": func() int {
			return time.Now().Year()
		},
		"add": func(a, b int) int {
			return a + b
		},
		"inc": func(a int) int {
			return a + 1
		},
		"dec": func(a int) int {
			return a - 1
		},
		"even": func(a int) bool {
			return a%2 == 0
		},
		"checkPermission": func(perms []permission.Permission, p string) bool {
			m := permission1.SufficientPermissionsFor(permissions.Permissions(p))

			for _, perm := range perms {
				if m[perm.Name] {
					return true
				}
			}
			return false
		},
		"checkIfNoNameExists": func(u user.User) bool {
			return len(u.Firstname) == 0 && len(u.Nickname) == 0 && len(u.Lastname) == 0
		},
		"formatUserName": func(u user.User) (name string) {
			if u.Firstname != u.Nickname {
				name = fmt.Sprintf("%s (%s) %s", u.Firstname, u.Nickname, u.Lastname)
			} else {
				name = fmt.Sprintf("%s %s", u.Firstname, u.Lastname)
			}
			return name
		},
	}
}
